# -*- coding: utf-8 -*-
"""Feature?Envy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KzEuV0lnMwxMZz6WTaUyuIP_XBEmz_wN
"""

# =====================================
# Importa√ß√£o de Bibliotecas Essenciais
# =====================================
import os
import json
import zipfile
import xml.etree.ElementTree as ET
from collections import Counter
from typing import Dict, List, Optional, Tuple

# =====================================
# Configura√ß√£o Inicial e Montagem do Google Drive
# =====================================
try:
    from google.colab import drive
    drive.mount('/content/drive')
except ImportError:
    print("Ambiente n√£o √© o Google Colab. A montagem do Drive foi ignorada.")

# =====================================
# Fun√ß√µes de Manipula√ß√£o de Arquivos .aia
# =====================================
def extrair_arquivo_aia(caminho_aia: str, caminho_extrair: str) -> bool:
    """
    Extrai o conte√∫do de um arquivo .aia para um diret√≥rio, limpando-o previamente.
    """
    try:
        if os.path.exists(caminho_extrair):
            for root, _, files in os.walk(caminho_extrair, topdown=False):
                for name in files:
                    os.remove(os.path.join(root, name))

        print(f"Tentando extrair arquivo {caminho_aia}...")
        with zipfile.ZipFile(caminho_aia, 'r') as arquivo_zip:
            arquivo_zip.extractall(caminho_extrair)
        print("‚úÖ Extra√ß√£o do arquivo .aia conclu√≠da com sucesso!")
        return True
    except FileNotFoundError:
        print(f"‚ùå Erro: Arquivo .aia n√£o encontrado em {caminho_aia}")
        return False
    except zipfile.BadZipFile:
        print(f"‚ùå Erro: Arquivo {caminho_aia} n√£o √© um arquivo zip v√°lido ou est√° corrompido.")
        return False
    except Exception as e:
        print(f"‚ùå Erro ao extrair arquivo .aia: {str(e)}")
        return False

def encontrar_arquivos_bky(caminho_extraido: str) -> List[str]:
    """
    Encontra todos os arquivos de blocos (.bky) dentro do diret√≥rio extra√≠do.
    """
    arquivos_bky = []
    for root, _, files in os.walk(caminho_extraido):
        if "src" in root: # Os arquivos .bky est√£o na pasta src
            for file in files:
                if file.endswith(".bky"):
                    arquivos_bky.append(os.path.join(root, file))
    return arquivos_bky

# =====================================
# Fun√ß√£o de Parsing do XML do Blockly
# =====================================
def parse_blockly_xml(xml_string: str) -> Optional[Dict]:
    """
    Converte uma string XML do Blockly para uma estrutura de dicion√°rio Python (AST).
    """
    BLOCKLY_NAMESPACE = "https://developers.google.com/blockly/xml"
    namespaces = {'blockly': BLOCKLY_NAMESPACE}

    try:
        root = ET.fromstring(xml_string)
        def extract_block_data(block_element):
            if block_element is None: return None
            block_data = {
                "type": block_element.get("type"),
                "id": block_element.get("id"),
                "mutation": {k: v for k, v in block_element.find("mutation").attrib.items()} if block_element.find("mutation") is not None else {},
                "fields": [{"name": f.get("name"), "text": f.text} for f in block_element.findall('blockly:field', namespaces)],
                "values": [{"name": v.get("name"), "block": extract_block_data(v.find('blockly:block', namespaces))} for v in block_element.findall('blockly:value', namespaces)],
                "statements": [{"name": s.get("name"), "block": extract_block_data(s.find('blockly:block', namespaces))} for s in block_element.findall('blockly:statement', namespaces)],
                "next": extract_block_data(block_element.find('blockly:next/blockly:block', namespaces))
            }
            return block_data
        return {"blocks": [extract_block_data(b) for b in root.findall('blockly:block', namespaces)]}
    except ET.ParseError as e:
        print(f"‚ùå Erro ao parsear XML: {e}")
        return None

# =====================================
# L√ìGICA DE DETE√á√ÉO DE FEATURE ENVY
# =====================================
def collect_component_accesses(block: Optional[Dict], access_list: List[str]):
    """
    Percorre recursivamente a AST de um bloco e coleta todos os acessos a componentes.
    """
    if not block:
        return

    block_type = block.get('type')

    # Verifica se o bloco √© um acesso a um componente (m√©todo, getter ou setter)
    if block_type in ['component_method', 'component_set_get']:
        instance_name = block.get('mutation', {}).get('instance_name')
        if instance_name:
            access_list.append(instance_name)

    # Continua a recurs√£o para todos os blocos filhos
    for value in block.get('values', []):
        collect_component_accesses(value.get('block'), access_list)
    for statement in block.get('statements', []):
        collect_component_accesses(statement.get('block'), access_list)

    collect_component_accesses(block.get('next'), access_list)


def find_feature_envy(structured_data: Dict, access_threshold: int) -> List[Dict]:
    """
    Analisa uma tela para encontrar manipuladores de eventos que exibem "Feature Envy".
    """
    envy_cases = []

    # Procura por blocos de manipulador de eventos
    event_handlers = [b for b in structured_data.get('blocks', []) if b.get('type') == 'component_event']

    for handler in event_handlers:
        handler_mutation = handler.get('mutation', {})
        host_component_name = handler_mutation.get('instance_name')
        event_name = handler_mutation.get('event_name')

        if not host_component_name:
            continue # Pula handlers malformados

        full_handler_name = f"{host_component_name}.{event_name}"

        # O corpo do handler est√° no primeiro statement
        body_start_block = None
        if handler.get('statements'):
            body_start_block = handler['statements'][0].get('block')

        if not body_start_block:
            continue # Handler sem corpo

        # Coleta todos os acessos a componentes dentro do corpo do handler
        accesses = []
        collect_component_accesses(body_start_block, accesses)

        # Calcula as m√©tricas
        access_counts = Counter(accesses)
        total_accesses = len(accesses)

        # Se n√£o houver acessos suficientes, n√£o √© relevante
        if total_accesses <= access_threshold:
            continue

        local_accesses = access_counts.get(host_component_name, 0)
        foreign_accesses = total_accesses - local_accesses

        # Aplica a heur√≠stica do Feature Envy
        if foreign_accesses > local_accesses:
            envy_details = {
                "handler_name": full_handler_name,
                "local_accesses": local_accesses,
                "foreign_accesses": foreign_accesses,
                "total_accesses": total_accesses,
                "envied_components": {comp: count for comp, count in access_counts.items() if comp != host_component_name}
            }
            envy_cases.append(envy_details)

    return envy_cases

# =====================================
# Fun√ß√µes de Gera√ß√£o de Relat√≥rio
# =====================================
def gerar_relatorio_feature_envy(envy_cases: List[Dict], screen_name: str):
    """
    Imprime um relat√≥rio leg√≠vel dos casos de Feature Envy encontrados.
    """
    print("-" * 70)
    print(f"üìÑ Relat√≥rio de 'Feature Envy' para a Tela: {screen_name}")
    print("-" * 70)

    if not envy_cases:
        print("üéâ Nenhum caso de Feature Envy detetado nesta tela.")
        return

    print(f"Encontrado(s) {len(envy_cases)} caso(s) de Feature Envy:\n")

    for i, case in enumerate(envy_cases, 1):
        print(f"üîµ Caso #{i}: Manipulador '{case['handler_name']}'")
        print(f"   - Acessos ao pr√≥prio componente (Locais): {case['local_accesses']}")
        print(f"   - Acessos a outros componentes (Externos): {case['foreign_accesses']}")
        print(f"   - Diagn√≥stico: Este bloco interage mais com outros componentes do que com o seu pr√≥prio, indicando um poss√≠vel problema de design.")

        # Detalha quais componentes s√£o "invejados"
        envied_str = ", ".join([f"{comp} ({count}x)" for comp, count in case['envied_components'].items()])
        print(f"   - Componentes Invejados: {envied_str}\n")

# =====================================
# Fun√ß√£o Principal de An√°lise
# =====================================
def analisar_projeto_completo(caminho_aia: str, access_threshold: int = 4):
    """
    Orquestra todo o processo de an√°lise de um arquivo .aia para Feature Envy.
    """
    diretorio_extraido = "/content/extracted_aia"

    if not extrair_arquivo_aia(caminho_aia, diretorio_extraido):
        return

    arquivos_bky = encontrar_arquivos_bky(diretorio_extraido)
    if not arquivos_bky:
        print("‚ö†Ô∏è Nenhum arquivo de blocos (.bky) encontrado no projeto.")
        return

    print("\nIniciando an√°lise de 'Feature Envy'...")

    for caminho_bky in arquivos_bky:
        screen_name = os.path.basename(caminho_bky).replace('.bky', '')

        with open(caminho_bky, 'r', encoding='utf-8') as f:
            xml_content = f.read()

        structured_data = parse_blockly_xml(xml_content)
        if not structured_data:
            print(f"N√£o foi poss√≠vel analisar os blocos da tela {screen_name}.")
            continue

        # An√°lise de Feature Envy
        casos_de_inveja = find_feature_envy(structured_data, access_threshold)
        gerar_relatorio_feature_envy(casos_de_inveja, screen_name)

    print("\n================ An√°lise Conclu√≠da ================")

# =====================================
# PONTO DE ENTRADA / EXECU√á√ÉO
# =====================================
# 1. Fa√ßa o upload do seu arquivo .aia para o Google Drive.
# 2. Atualize o caminho na vari√°vel `caminho_do_arquivo_aia` abaixo.

caminho_do_arquivo_aia ="/content/drive/MyDrive/Colab Notebooks/smells_appinventor2/projectos_para_analise/LONG_METHOD_appListaDeTarefas.aia" # <-- MUDE ESTE CAMINHO

# Par√¢metros da an√°lise
# Limite m√≠nimo de acessos totais para um bloco ser considerado para an√°lise.
# Ajuda a ignorar blocos muito simples.
LIMITE_MINIMO_DE_ACESSOS = 4

if os.path.exists(caminho_do_arquivo_aia):
    analisar_projeto_completo(caminho_do_arquivo_aia, LIMITE_MINIMO_DE_ACESSOS)
else:
    print(f"‚ùå ERRO CR√çTICO: O arquivo .aia n√£o foi encontrado em '{caminho_do_arquivo_aia}'.")
    print("   Por favor, verifique o caminho e certifique-se de que o arquivo existe no seu Google Drive.")
    print("   Lembre-se de que o caminho diferencia mai√∫sculas de min√∫sculas.")
