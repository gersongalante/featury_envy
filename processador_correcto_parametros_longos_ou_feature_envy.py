# -*- coding: utf-8 -*-
"""Correcto parametros longos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WAudbGnF9AsJKmPMHOG0Yu6kpgcniKsx
"""

# =====================================
# Importa√ß√£o de Bibliotecas Essenciais
# =====================================
import os
import json
import zipfile
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional

# =====================================
# Configura√ß√£o Inicial e Montagem do Google Drive
# =====================================
try:
    from google.colab import drive
    drive.mount('/content/drive')
    print("‚úÖ Google Drive montado com sucesso.")
except ImportError:
    print("Ambiente n√£o √© o Google Colab. A montagem do Drive foi ignorada.")
except Exception as e:
    print(f"‚ö†Ô∏è  Aviso ao montar o Drive: {e}")


# =====================================
# Fun√ß√µes de Manipula√ß√£o de Arquivos .aia
# =====================================
def extrair_arquivo_aia(caminho_aia: str, caminho_extrair: str) -> bool:
    """
    Extrai o conte√∫do de um arquivo .aia para um diret√≥rio, limpando-o previamente.
    """
    try:
        if os.path.exists(caminho_extrair):
            import shutil
            shutil.rmtree(caminho_extrair)
        os.makedirs(caminho_extrair)

        print(f"\n[ETAPA 1/3] Extraindo o arquivo '{os.path.basename(caminho_aia)}'...")
        with zipfile.ZipFile(caminho_aia, 'r') as arquivo_zip:
            arquivo_zip.extractall(caminho_extrair)
        print("‚úÖ Extra√ß√£o conclu√≠da com sucesso!")
        return True
    except FileNotFoundError:
        print(f"‚ùå Erro: Arquivo .aia n√£o encontrado em {caminho_aia}")
        return False
    except zipfile.BadZipFile:
        print(f"‚ùå Erro: Arquivo {caminho_aia} n√£o √© um arquivo zip v√°lido ou est√° corrompido.")
        return False
    except Exception as e:
        print(f"‚ùå Erro ao extrair arquivo .aia: {str(e)}")
        return False

def encontrar_arquivos_bky(caminho_extraido: str) -> List[str]:
    """
    Encontra todos os arquivos de blocos (.bky) dentro do diret√≥rio extra√≠do.
    """
    print("\n[ETAPA 2/3] Procurando por arquivos de blocos (.bky)...")
    arquivos_bky = []
    src_path = os.path.join(caminho_extraido, "src")
    if not os.path.exists(src_path):
        print("‚ö†Ô∏è  Diret√≥rio 'src' n√£o encontrado no projeto.")
        return []

    for root, _, files in os.walk(src_path):
        for file in files:
            if file.endswith(".bky"):
                arquivos_bky.append(os.path.join(root, file))

    if arquivos_bky:
        print(f"‚úÖ Encontrados {len(arquivos_bky)} arquivos de tela.")
    else:
        print("‚ö†Ô∏è Nenhum arquivo .bky foi encontrado.")

    return arquivos_bky


# =====================================
# Fun√ß√µes de An√°lise e Transforma√ß√£o (XML -> AST -> Relat√≥rio)
# =====================================
def parse_blockly_xml_to_ast(xml_string: str) -> Optional[Dict]:
    """
    Converte uma string XML do Blockly para uma estrutura de dicion√°rio Python (AST).
    Esta √© a etapa de transforma√ß√£o principal.
    """
    # Namespaces usados pelo App Inventor
    BLOCKLY_NS = "https://developers.google.com/blockly/xml"
    XHTML_NS = "http://www.w3.org/1999/xhtml"

    # Nota√ß√£o de Clark para busca com namespaces
    BN = f"{{{BLOCKLY_NS}}}"
    XN = f"{{{XHTML_NS}}}"

    try:
        root = ET.fromstring(xml_string)

        def extract_block_data(block_element):
            if block_element is None:
                return None

            mutation_element = block_element.find(f"{BN}mutation")
            mutation_data = {}
            if mutation_element is not None:
                mutation_data = {k: v for k, v in mutation_element.attrib.items()}
                # Extrai os nomes dos par√¢metros dos elementos <arg>
                mutation_data['args'] = [arg.get('name') for arg in mutation_element.findall(f'{XN}arg')]

            block_data = {
                "type": block_element.get("type"),
                "id": block_element.get("id"),
                "mutation": mutation_data,
                "fields": [{"name": f.get("name"), "text": f.text} for f in block_element.findall(f'{BN}field')],
                "values": [{"name": v.get("name"), "block": extract_block_data(v.find(f'{BN}block'))} for v in block_element.findall(f'{BN}value')],
                "statements": [{"name": s.get("name"), "block": extract_block_data(s.find(f'{BN}block'))} for s in block_element.findall(f'{BN}statement')],
                "next": extract_block_data(block_element.find(f'{BN}next/{BN}block'))
            }
            return block_data

        return {"blocks": [extract_block_data(b) for b in root.findall(f'{BN}block')]}

    except ET.ParseError as e:
        print(f"‚ùå Erro ao parsear XML: {e}")
        return None

def find_procedures_in_ast(ast: Dict) -> List[Dict]:
    """
    Analisa a AST e retorna uma lista de todos os procedimentos definidos.
    CORRIGIDO: Extrai os par√¢metros dos elementos 'field' com nome 'VAR...'.
    """
    all_procedures = []
    if not ast or 'blocks' not in ast:
        return []

    procedure_definitions = [
        b for b in ast.get('blocks', [])
        if b and b.get('type') in ['procedures_defnoreturn', 'procedures_defreturn']
    ]

    for proc in procedure_definitions:
        if not proc: continue

        proc_name = 'ProcedimentoSemNome'
        parameters = []

        # Itera pelos campos para encontrar o nome e os par√¢metros
        for field in proc.get('fields', []):
            field_name = field.get('name')
            if field_name == 'NAME':
                proc_name = field.get('text', 'ProcedimentoSemNome')
            elif field_name and field_name.startswith('VAR'):
                # Adiciona o texto do campo (nome do par√¢metro) √† lista
                if field.get('text'):
                    parameters.append(field.get('text'))

        proc_details = {
            "procedure_name": proc_name,
            "parameter_count": len(parameters),
            "parameters": parameters,
        }
        all_procedures.append(proc_details)

    return all_procedures

def gerar_relatorio_smell(procedures: List[Dict], threshold: int):
    """
    Imprime um relat√≥rio focado apenas nos procedimentos com o code smell.
    """
    smelly_procedures = [p for p in procedures if p['parameter_count'] > threshold]

    print("\n" + "=" * 20 + " RELAT√ìRIO DE CODE SMELL " + "=" * 20)
    print(f"Analisando 'Lista de Par√¢metros Longa' (Limite > {threshold} par√¢metros)")
    print("-" * 64)

    if not smelly_procedures:
        print(f"üéâ Nenhum procedimento com mais de {threshold} par√¢metros foi detectado.")
        return

    print(f"Encontrado(s) {len(smelly_procedures)} procedimento(s) suspeito(s):\n")

    for i, case in enumerate(smelly_procedures, 1):
        print(f"üî¥ CASO #{i}: Procedimento '{case['procedure_name']}'")
        print(f"   - Par√¢metros Encontrados: {case['parameter_count']} (Limite era {threshold})")
        print(f"   - Nomes dos Par√¢metros: {', '.join(case['parameters'])}")
        print(f"   - Diagn√≥stico: Este procedimento tem uma lista de par√¢metros longa, o que pode dificultar o seu uso e manuten√ß√£o.")
        print(f"   - Sugest√£o: Considere agrupar par√¢metros em uma estrutura de dados (como uma lista ou dicion√°rio) ou dividir o procedimento em fun√ß√µes menores.\n")


# =====================================
# Fun√ß√£o Principal de An√°lise
# =====================================
def analisar_projeto_completo(caminho_aia: str, param_threshold: int):
    """
    Orquestra todo o processo de an√°lise de um arquivo .aia.
    """
    diretorio_extraido = "/content/extracted_aia"

    if not extrair_arquivo_aia(caminho_aia, diretorio_extraido):
        return

    arquivos_bky = encontrar_arquivos_bky(diretorio_extraido)
    if not arquivos_bky:
        return

    print("\n[ETAPA 3/3] Analisando cada tela individualmente...")

    for caminho_bky in arquivos_bky:
        screen_name = os.path.basename(caminho_bky).replace('.bky', '')
        print("\n" + "#" * 70)
        print(f"## Analisando a Tela: {screen_name}")
        print("#" * 70)

        # --- Transforma√ß√£o 1: Ler o XML Bruto ---
        try:
            with open(caminho_bky, 'r', encoding='utf-8') as f:
                xml_content = f.read()
            print("\n---------- 1. XML Original (.bky) ----------")
            print(xml_content[:1000] + "..." if len(xml_content) > 1000 else xml_content)
        except Exception as e:
            print(f"‚ùå N√£o foi poss√≠vel ler o arquivo {caminho_bky}: {e}")
            continue

        # --- Transforma√ß√£o 2: Converter XML para AST (Dicion√°rio Python) ---
        ast = parse_blockly_xml_to_ast(xml_content)
        if not ast:
            print(f"‚ö†Ô∏è N√£o foi poss√≠vel gerar a AST para a tela {screen_name}.")
            continue
        print("\n\n---------- 2. Estrutura de Dados (AST) Gerada ----------")
        # Usamos json.dumps para imprimir o dicion√°rio de forma leg√≠vel
        print(json.dumps(ast, indent=2))

        # --- Transforma√ß√£o 3: Analisar a AST e Gerar Relat√≥rio ---
        todos_os_procedimentos = find_procedures_in_ast(ast)
        print("\n\n---------- 3. An√°lise e Relat√≥rio Final ----------")
        if not todos_os_procedimentos:
            print("Nenhum procedimento definido foi encontrado nesta tela.")
        else:
            gerar_relatorio_smell(todos_os_procedimentos, param_threshold)

    print("\n\n================ AN√ÅLISE COMPLETA CONCLU√çDA ================")


# =====================================
# PONTO DE ENTRADA / EXECU√á√ÉO
# =====================================
if __name__ == "__main__":
    # <-- MUDE ESTE CAMINHO para o seu arquivo .aia
    caminho_do_arquivo_aia = "/content/drive/MyDrive/Colab Notebooks/smells_appinventor2/projectos_para_analise/ListaPARAMETRO_GERSON_appListaDeTarefas.aia"

    # Um procedimento √© considerado "longo" se tiver MAIS do que este n√∫mero de par√¢metros.
    LIMITE_DE_PARAMETROS = 3

    if os.path.exists(caminho_do_arquivo_aia):
        analisar_projeto_completo(caminho_do_arquivo_aia, LIMITE_DE_PARAMETROS)
    else:
        print(f"‚ùå ERRO CR√çTICO: O arquivo .aia n√£o foi encontrado em '{caminho_do_arquivo_aia}'.")
        print("   Por favor, verifique o caminho e certifique-se de que o arquivo existe no seu Google Drive.")
        print("   Lembre-se de que o caminho diferencia mai√∫sculas de min√∫sculas.")